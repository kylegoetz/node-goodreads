// Generated by CoffeeScript 1.12.2

/* Goodreads - Handles all connectivity to Goodreads API */


/* API Docs: https://www.goodreads.com/api */

(function() {
  var Goodreads, http, oauth, querystring, sys, xml2js;

  var request = require('request');

  xml2js = require('xml2js');

  oauth = (require('oauth')).OAuth;

  sys = require('sys');

  querystring = require('querystring');

  Goodreads = (function() {

    /* CONFIG */
    var clone;

    function Goodreads(config) {
      this.options = {
        host: 'www.goodreads.com',
        port: 80,
        key: config.key,
        secret: config.secret,
        callback: config.callback || 'https://localhost:3000/callback',
        method: 'GET',
        path: '',
        oauth_request_url: 'https://goodreads.com/oauth/request_token',
        oauth_access_url: 'https://goodreads.com/oauth/access_token',
        oauth_version: '1.0',
        oauth_encryption: 'HMAC-SHA1'
      };
      this.oauthAccessToken = '';
      this.oauthAcessTokenSecret = '';
      this.client = null;
    }

    Goodreads.prototype.configure = function(gr_key, gr_secret, gr_callback) {
      this.options.key = gr_key || this.options.key;
      this.options.secret = gr_secret || this.options.secret;
      return this.options.callback = gr_callback || this.options.callback;
    };


    /* USER */

    Goodreads.prototype.showUser = function(username) {
      this.options.path = "https://www.goodreads.com/user/show.xml?key=" + this.options.key + "&username=" + username;
      return this.getRequest();
    };


    /* BOOKSHELVES */

    //Returns array of shelf objects
    Goodreads.prototype.getShelves = function(userId) {
      this.options.path = 'https://www.goodreads.com/shelf/list.xml?user_id=' + userId + "&key=" + this.options.key;
      return this.getRequest()
      .then(obj=>obj.shelves.user_shelf);
    };

    //Returns shelf object
    Goodreads.prototype.getSingleShelf = function(shelfOptions) {
      var queryOptions, userID;
      shelfOptions.key = this.options.key;
      queryOptions = querystring.stringify(shelfOptions);
      userID = shelfOptions.userID;
      delete shelfOptions.userID;
      this.options.path = 'https://www.goodreads.com/review/list/' + userID + '.xml?' + querystring.stringify(shelfOptions);
      return this.getRequest();
    };


    /* REVIEWS */

    Goodreads.prototype.getReviews = async function(userId) {
      this.options.path = 'https://www.goodreads.com/review/list.xml?per_page=20&sort=date_added&order=d&page=1&v=2&id=' + userId + "&key=" + this.options.key;
      const response = await this.getRequest();
      return response.status.review;
    };

    Goodreads.prototype.getFriends = function(userId, accessToken, accessTokenSecret) {
      var oa;
      this.options.path = 'https://www.goodreads.com/friend/user/' + userId + '.xml?&key=' + this.options.key;
      oa = new oauth(this.options.oauth_request_url, this.options.oauth_access_url, this.options.key, this.options.secret, this.options.oauth_version, this.options.callback, this.options.oauth_encryption);
      return new Promise((resolve, reject) => {
        oa.getProtectedResource(this.options.path, 'GET', accessToken, accessTokenSecret, function(error, data, response) {
          if (error) {
            return reject('Error getting OAuth request token : ' + JSON.stringify(error));
          }
          return resolve(data);
        });
      });
    };

    Goodreads.prototype.searchBooks = function(q) {
      this.options.path = "https://www.goodreads.com/search/index.xml?key=" + this.options.key + "&q=" + (encodeURI(q));
      return this.getRequest();
    };

    Goodreads.prototype.requestToken = function() {
      var oa;
      oa = new oauth(this.options.oauth_request_url, this.options.oauth_access_url, this.options.key, this.options.secret, this.options.oauth_version, this.options.callback, this.options.oauth_encryption);
      return new Promise((resolve, reject) => {
        oa.getOAuthRequestToken(function(error, oauthToken, oauthTokenSecret, results) {
          var url;
          if (error) {
            return reject('Error getting OAuth request token : ' + JSON.stringify(error));
          }
          url = 'https://goodreads.com/oauth/authorize?oauth_token=' + oauthToken + '&oauth_callback=' + oa._authorize_callback;
          return resolve({
            oauthToken: oauthToken,
            oauthTokenSecret: oauthTokenSecret,
            url: url
          });
        });
      });
    };

    Goodreads.prototype.processCallback = function(oauthToken, oauthTokenSecret, authorize) {
      var oa;
      oa = new oauth(this.options.oauth_request_url, this.options.oauth_access_url, this.options.key, this.options.secret, this.options.oauth_version, this.options.callback, this.options.oauth_encryption);
      return new Promise((resolve, reject) => {
        oa.getOAuthAccessToken(oauthToken, oauthTokenSecret, authorize, function(error, oauthAccessToken, oauthAccessTokenSecret, results) {
          var parser;
          parser = new xml2js.Parser();
          if (error) {
            return reject('Error getting OAuth access token : ' + (sys.inspect(error)) + '[' + oauthAccessToken + '] [' + oauthAccessTokenSecret + '] [' + (sys.inspect(results)) + ']');
          }
          oa.get('https://www.goodreads.com/api/auth_user', oauthAccessToken, oauthAccessTokenSecret, function(error, data, response) {
            if (error) {
              return reject('Error getting User ID : ' + (sys.inspect(error)));
            }
            return parser.parseString(data);
          });
          parser.on('end', function(result) {
            result = result.GoodreadsResponse;
            if (result.user[0]['$'].id !== null) {
              return resolve({
                'username': result.user.name,
                'userid': result.user[0]['$'].id,
                'success': 1,
                'accessToken': oauthAccessToken,
                'accessTokenSecret': oauthAccessTokenSecret
              });
            } else {
              return reject('Error: Invalid XML response received from Goodreads', 500);
            }
          });
        });
      });
    };

    Goodreads.prototype.getRequest = function() {
      var _options, parser, tmp;
      _options = this.options;
      tmp = [];
      parser = new xml2js.Parser();

      return new Promise((resolve, reject) => {
        request(this.options.path , function (error, response, body) {
          if(  error  ) {
            return reject(error);
          }
          if(  body.indexOf('<error>') === 0  ) {
            return reject(new Error(body.split('<error>')[1].split('</error>')[0]));
          }
          parser.parseString(body, function (err, result) {
            if(  error  ) {
              return reject(error);
            }
            const grr = result.GoodreadsResponse;
            delete grr.Response;
            const rv = {};
            Object.keys(grr).forEach(key=>{
              rv[key] = cleanUpItem(grr[key][0]);
            });
            return resolve(rv);
          });
          function cleanUpXml(item) {
            //Handle the non-array $ item of a response
            if(  typeof item === 'object' && !item.hasOwnProperty('length')  ) {
              return item;
            }
            //String-valued items often are of the form ['someval']
            if(  typeof item[0] === 'string'  ) {
              return item[0];
            }
            //plain old array of objects should be cleaned up recursively
            if(  typeof item[0] === 'object' && !item[0].hasOwnProperty('$')  ) {
              // return cleanUpItem(item[0]);
              return item.map(cleanUpItem);
            }
            //Most values are of the form {$:{metadata},_:string(data)}
            if(  item[0].$.nil === 'true'  ) {
              return null;
            }
            switch(item[0].$.type) {
              case 'integer':
                return parseInt(item[0]._);
              case 'boolean':
                return item[0]._==='true';
              default:
                return;
            }
          }
          function cleanUpItem(item) {
            if(  Array.isArray(item)  ) {

            }
            const rv = {};
            delete item.$; //Don't need to bother with metadata
            Object.keys(item).forEach(key=>{
              return rv[key]=cleanUpXml(item[key]);
            });
            return rv;
          }
        });
      });


      /*
      return http.request(_options, function(res) {
        res.setEncoding('utf8');
        res.on('data', function(chunk) {
          return tmp.push(chunk);
        });
        res.on('end', function(e) {
          var body;
          body = tmp.join('');
          return parser.parseString(body);
        });
        return parser.on('end', function(result) {
          return callback(result);
        });
      }).end();
      */
    };

    clone = function(obj) {
      if (obj !== null || typeof obj !== 'object') {
        return obj;
      }
    };

    return Goodreads;

  })();

  module.exports = {
    client: function(options) {
      return new Goodreads(options);
    }
  };

}).call(this);
